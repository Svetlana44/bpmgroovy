# MongoDB vs Redis - Сравнение для QA Automation

## Краткое сравнение

| Характеристика | MongoDB | Redis |
|---------------|---------|-------|
| **Тип БД** | Документо-ориентированная NoSQL | In-memory key-value store |
| **Основное назначение** | Хранение документов, сложные запросы | Кэширование, очереди, сессии |
| **Хранение данных** | На диске (с опциональным кэшем в памяти) | В памяти (RAM) |
| **Структура данных** | Документы (JSON-подобные) | Key-Value, Strings, Lists, Sets, Hashes, Sorted Sets |
| **Скорость чтения** | Быстро (зависит от индексов) | Очень быстро (в памяти) |
| **Скорость записи** | Быстро | Очень быстро |
| **Персистентность** | Да (по умолчанию) | Опционально (RDB, AOF) |
| **Сложные запросы** | Да (агрегации, JOIN-подобные) | Ограниченно |
| **Масштабируемость** | Горизонтальная (sharding) | Горизонтальная (cluster) |
| **Использование в тестах** | Проверка данных, подготовка данных | Кэширование, мокирование, тестовые данные |

---

## MongoDB

### Что это?
**MongoDB** - документо-ориентированная NoSQL база данных, которая хранит данные в виде документов (JSON-подобные структуры).

### Основные характеристики:

1. **Хранение данных:**
   - Документы в коллекциях (аналог таблиц в SQL)
   - Гибкая схема (не требуется строгая структура)
   - Хранение на диске с опциональным кэшем

2. **Запросы:**
   - Богатый язык запросов
   - Агрегации (аналог GROUP BY в SQL)
   - Индексы для быстрого поиска
   - Поддержка сложных фильтров

3. **Использование:**
   - Хранение пользовательских данных
   - Логи, события
   - Контент-менеджмент
   - Каталоги товаров

### Пример использования в тестах:

```java
// Подготовка тестовых данных
Document user = new Document("name", "Test User")
        .append("email", "test@example.com");
collection.insertOne(user);

// Проверка данных после теста
Document found = collection.find(Filters.eq("email", "test@example.com")).first();
assertNotNull(found);
assertEquals("Test User", found.getString("name"));

// Очистка после теста
collection.deleteMany(Filters.eq("email", "test@example.com"));
```

### Когда использовать MongoDB в тестах:
- Нужно проверить сложные данные (документы с вложенными объектами)
- Требуется подготовка тестовых данных с различной структурой
- Нужны сложные запросы (агрегации, фильтры)
- Тестирование приложения, которое использует MongoDB
- Проверка состояния данных после операций

---

## Redis

### Что это?
**Redis** (Remote Dictionary Server) - in-memory key-value хранилище данных, которое хранит все данные в оперативной памяти.

### Основные характеристики:

1. **Хранение данных:**
   - Все данные в RAM (очень быстро)
   - Опциональная персистентность (RDB snapshots, AOF)
   - Различные типы данных: Strings, Lists, Sets, Hashes, Sorted Sets

2. **Скорость:**
   - Очень быстрые операции чтения/записи
   - Поддержка атомарных операций
   - Pub/Sub для сообщений

3. **Использование:**
   - Кэширование
   - Сессии пользователей
   - Очереди сообщений
   - Счетчики, рейтинги
   - Rate limiting

### Пример использования в тестах:

```java
// Кэширование результатов для ускорения тестов
jedis.set("user:123", "{\"name\":\"John\",\"email\":\"john@example.com\"}");
String cached = jedis.get("user:123");

// Очистка кэша перед тестом
jedis.flushDB();

// Проверка сессии
jedis.setex("session:abc123", 3600, "user:123");
String session = jedis.get("session:abc123");

// Использование как очереди для тестовых данных
jedis.lpush("test:queue", "task1", "task2", "task3");
String task = jedis.rpop("test:queue");
```

### Когда использовать Redis в тестах:
- Нужно быстрое кэширование результатов
- Тестирование приложения, которое использует Redis
- Проверка сессий пользователей
- Мокирование внешних сервисов (быстрое хранилище)
- Тестирование очередей сообщений
- Проверка rate limiting

---

## Сравнение по сценариям использования

### Сценарий 1: Хранение пользовательских данных

**MongoDB:**
```java
// Хранение полного профиля пользователя
Document user = new Document("id", 123)
        .append("name", "John Doe")
        .append("email", "john@example.com")
        .append("address", new Document("city", "Moscow", "street", "Lenina"))
        .append("orders", Arrays.asList("order1", "order2"));
collection.insertOne(user);

// Сложный запрос
List<Document> users = collection.find(
    Filters.and(
        Filters.eq("address.city", "Moscow"),
        Filters.gt("orders", 0)
    )
).into(new ArrayList<>());
```

**Redis:**
```java
// Хранение как JSON строка
jedis.set("user:123", "{\"name\":\"John\",\"email\":\"john@example.com\"}");

// Или как Hash
jedis.hset("user:123", "name", "John Doe");
jedis.hset("user:123", "email", "john@example.com");
Map<String, String> user = jedis.hgetAll("user:123");
```

**Вывод:** MongoDB лучше для сложных структур, Redis - для простых key-value.

---

### Сценарий 2: Кэширование

**MongoDB:**
```java
// Не оптимально для кэширования
// Требуется запрос к диску
Document cached = collection.find(Filters.eq("cache_key", "user:123")).first();
```

**Redis:**
```java
// Идеально для кэширования
jedis.setex("cache:user:123", 3600, cachedData);
String cached = jedis.get("cache:user:123");
```

**Вывод:** Redis значительно быстрее для кэширования (данные в памяти).

---

### Сценарий 3: Очереди сообщений

**MongoDB:**
```java
// Можно использовать, но не оптимально
collection.insertOne(new Document("queue", "test")
        .append("message", "task1")
        .append("timestamp", new Date()));
```

**Redis:**
```java
// Идеально для очередей
jedis.lpush("queue:test", "task1", "task2");
String task = jedis.rpop("queue:test");
```

**Вывод:** Redis лучше подходит для очередей благодаря атомарным операциям.

---

### Сценарий 4: Сложные запросы и агрегации

**MongoDB:**
```java
// Богатые возможности запросов
List<Document> result = collection.aggregate(Arrays.asList(
    Aggregates.match(Filters.gt("age", 18)),
    Aggregates.group("$city", Accumulators.sum("count", 1)),
    Aggregates.sort(Sorts.descending("count"))
)).into(new ArrayList<>());
```

**Redis:**
```java
// Ограниченные возможности
// Нет встроенных агрегаций
// Нужно получать все данные и обрабатывать в приложении
Set<String> keys = jedis.keys("user:*");
// Обработка в Java коде
```

**Вывод:** MongoDB лучше для сложных запросов и аналитики.

---

## Практические рекомендации для QA

### Когда использовать MongoDB:

1. **Тестирование приложения, использующего MongoDB:**
   - Проверка сохранения данных
   - Валидация структуры документов
   - Проверка индексов

2. **Подготовка тестовых данных:**
   - Сложные структуры данных
   - Вложенные объекты
   - Массивы документов

3. **Проверка состояния после тестов:**
   - Сложные запросы для валидации
   - Агрегации для подсчета статистики
   - Проверка связей между документами

### Когда использовать Redis:

1. **Кэширование в тестах:**
   - Ускорение тестов через кэш
   - Проверка работы кэша приложения

2. **Тестирование сессий:**
   - Проверка сессий пользователей
   - Тестирование истечения сессий

3. **Мокирование внешних сервисов:**
   - Быстрое хранилище для моков
   - Временное хранение тестовых данных

4. **Тестирование очередей:**
   - Проверка работы очередей сообщений
   - Тестирование Pub/Sub

---

## Примеры использования в тестах

### MongoDB - Проверка данных после API теста

```java
@Test
void testCreateUser() {
    // API тест
    given()
        .body("{\"name\":\"John\",\"email\":\"john@example.com\"}")
        .post("/api/users")
        .then()
        .statusCode(201);
    
    // Проверка в MongoDB
    Document user = collection.find(
        Filters.eq("email", "john@example.com")
    ).first();
    
    assertNotNull(user);
    assertEquals("John", user.getString("name"));
}
```

### Redis - Кэширование результатов

```java
@Test
void testCachedUser() {
    // Подготовка кэша
    jedis.setex("user:123", 3600, "{\"name\":\"John\"}");
    
    // API тест (должен использовать кэш)
    given()
        .get("/api/users/123")
        .then()
        .statusCode(200)
        .body("name", equalTo("John"));
    
    // Проверка, что кэш использован
    assertTrue(jedis.exists("user:123"));
}
```

---

## Полезные ресурсы

### MongoDB:
- Официальная документация: https://www.mongodb.com/docs/
- Java Driver: https://www.mongodb.com/docs/drivers/java/
- Примеры: `../examples/database/MongoDBExampleTest.java`

### Redis:
- Официальная документация: https://redis.io/docs/
- Jedis (Java клиент): https://github.com/redis/jedis
- Lettuce (альтернативный Java клиент): https://lettuce.io/

---

## Итоговая таблица выбора

| Задача | MongoDB | Redis |
|--------|---------|-------|
| Хранение пользовательских данных | Да | Нет |
| Кэширование | Опционально | Да |
| Очереди сообщений | Опционально | Да |
| Сложные запросы | Да | Нет |
| Сессии пользователей | Опционально | Да |
| Аналитика и агрегации | Да | Нет |
| Быстрый доступ к данным | Опционально | Да |
| Персистентное хранение | Да | Опционально |

---

## Выводы

1. **MongoDB** - для хранения сложных данных, документов, когда нужны сложные запросы
2. **Redis** - для кэширования, очередей, сессий, когда нужна максимальная скорость
3. **В тестах** - часто используют оба: MongoDB для проверки данных, Redis для кэширования и моков
4. **Выбор зависит от задачи** - нет универсального решения, каждый инструмент решает свои задачи

---

**Помните:** В реальных проектах MongoDB и Redis часто используются вместе, дополняя друг друга.
