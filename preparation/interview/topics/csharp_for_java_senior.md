# C# для Java‑сеньора (объяснение как джуну)

Ниже ответы для заучивания: формулировки короткие и понятные.

## Модификаторы доступа

**Java**
- `private` — только внутри класса
- `protected` — класс + наследники + пакет
- `default` (package‑private) — только в пакете
- `public` — везде

**C#**
- `private` — только внутри класса
- `protected` — класс + наследники
- `internal` — только в текущей сборке (assembly)
- `protected internal` — assembly или наследники
- `private protected` — наследники в той же assembly
- `public` — везде

Коротко: в C# нет `default`, вместо него — `internal`.

## Абстрактный класс vs интерфейс (C#)

**Абстрактный класс**
- может иметь реализацию методов
- может иметь поля и конструктор
- наследование только от одного класса

**Интерфейс**
- может иметь default‑реализацию (C# 8+)
- может иметь static‑методы
- не имеет нестатических полей
- можно реализовать много интерфейсов

## Переопределение vs перегрузка

**Перегрузка (overload)**  
Одинаковое имя, разные параметры. Можно перегружать и статические методы.

**Переопределение (override)**  
Новая реализация для `virtual/abstract/override` метода базового класса.

## Можно ли перегрузить статический метод?

Да. Перегрузка — это compile‑time механизм.

## Можно ли переопределить статический метод?

Нет. Статика не участвует в полиморфизме.  
Можно только **скрыть** через `new`.

```csharp
public class A { public static void M() {} }
public class B : A { public new static void M() {} }
```

## Можно ли у абстрактного класса написать sealed/final?

Нет. `abstract` означает "надо наследовать", `sealed/final` — "нельзя наследовать".

## Порядок вызова конструкторов

Сначала вызывается конструктор базового класса, затем — производного.  
Если не указано — вызывается базовый без параметров.

## Есть ли конструктор у абстрактного класса?

Да. Он нужен для инициализации базовой части объекта.

## throw vs throws / throw vs throw ex

**Java**
- `throw` — выбросить исключение
- `throws` — объявить, что метод может выбросить исключение

**C#**
- `throw;` — пробросить и **сохранить стек**
- `throw ex;` — **перезаписать стек** (плохо)

## Обработка исключений (C#)

`try / catch / finally`, все исключения — runtime (нет checked‑исключений).

## Коллекции (C#)

- `IEnumerable<T>`, `ICollection<T>`, `IList<T>`
- `IDictionary<TKey,TValue>`, `ISet<T>`
- `Queue<T>`, `Stack<T>`, `LinkedList<T>`

## Deque vs Queue

В .NET нет встроенного `Deque`, обычно используют `LinkedList<T>`.  
Queue — FIFO (добавление в конец, извлечение из начала).  
Deque — можно с обеих сторон.

## Почему Map отдельно от Collection (Java)

`Map` — это пары ключ‑значение, модель данных отличается от коллекции элементов.

## Почему в Java нет множественного наследования классов

Из‑за проблемы «ромба», конфликтов реализации и сложности поддержки.  
Вместо этого — множественное наследование интерфейсов.

## Что будет, если убрать полиморфизм

Пропадут `virtual/override/abstract`, DI и большая часть фреймворков.  
ОО‑подход разрушится, язык станет гораздо беднее.
